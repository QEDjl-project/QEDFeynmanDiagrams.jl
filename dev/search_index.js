var documenterSearchIndex = {"docs":
[{"location":"lib/internal/#Internal-functions-and-functionality","page":"Internal","title":"Internal functions and functionality","text":"","category":"section"},{"location":"lib/internal/","page":"Internal","title":"Internal","text":"CurrentModule = QEDFeynmanDiagrams","category":"page"},{"location":"lib/internal/","page":"Internal","title":"Internal","text":"Pages = [\"internal.md\"]","category":"page"},{"location":"lib/internal/#Types","page":"Internal","title":"Types","text":"","category":"section"},{"location":"lib/internal/","page":"Internal","title":"Internal","text":"AbstractTreeLevelFeynmanDiagram","category":"page"},{"location":"lib/internal/#QEDFeynmanDiagrams.AbstractTreeLevelFeynmanDiagram","page":"Internal","title":"QEDFeynmanDiagrams.AbstractTreeLevelFeynmanDiagram","text":"AbstractTreeLevelFeynmanDiagram\n\nAbstract base type for FeynmanDiagrams. Must implement the functions\n\nprocess(::AbstractTreeLevelFeynmanDiagram)::QEDbase.AbstractProcessDefinition\nvirtual_particles(::AbstractTreeLevelFeynmanDiagram)::NTuple{N, Tuple{QEDbase.AbstractParticleType, BitArray}}\n\nBy using the QEDbase.AbstractProcessDefinition interface, the function external_particles is automatically provided.\n\nFor more information on what the interface functions should do, see their documentation: process, virtual_particles\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#Functions","page":"Internal","title":"Functions","text":"","category":"section"},{"location":"lib/internal/","page":"Internal","title":"Internal","text":"_is_index_valid_combination\n_pseudo_virtual_particles\nare_total\ncontains\ndisjunct\nmake_up","category":"page"},{"location":"lib/internal/#QEDFeynmanDiagrams._is_index_valid_combination","page":"Internal","title":"QEDFeynmanDiagrams._is_index_valid_combination","text":"_is_index_valid_combination(proc::AbstractProcessDefinition, index::Tuple)\n\nInternal function for DAG generation. Checks for a given process and a spin/pol combination whether the spin/pol combination is part of the process, including checking for QEDbase.SyncedPolarization and QEDbase.SyncedSpin.\n\n\n\n\n\n","category":"function"},{"location":"lib/internal/#QEDFeynmanDiagrams._pseudo_virtual_particles","page":"Internal","title":"QEDFeynmanDiagrams._pseudo_virtual_particles","text":"_pseudo_virtual_particles\n\nReturn a vector of VirtualParticle for each external particle. These are not actually virtual particles, but can be helpful as entry points.\n\n\n\n\n\n","category":"function"},{"location":"lib/internal/#QEDFeynmanDiagrams.are_total","page":"Internal","title":"QEDFeynmanDiagrams.are_total","text":"are_total(a::VirtualParticle, b::VirtualParticle, c::VirtualParticle)\n\nReturn true if a, b and c combined contain all external particles exactly once.\n\n\n\n\n\n","category":"function"},{"location":"lib/internal/#QEDFeynmanDiagrams.contains","page":"Internal","title":"QEDFeynmanDiagrams.contains","text":"contains(a::VirtualParticle, b::VirtualParticle)\n\nReturns true if the set of particles contributing to a are contains the set of particles contributing to b.\n\n\n\n\n\n","category":"function"},{"location":"lib/internal/#QEDFeynmanDiagrams.disjunct","page":"Internal","title":"QEDFeynmanDiagrams.disjunct","text":"disjunct(a::VirtualParticle, b::VirtualParticle)\n\nReturn true if the momenta contributions of a and b are disjunct.\n\n\n\n\n\n","category":"function"},{"location":"lib/internal/#QEDFeynmanDiagrams.make_up","page":"Internal","title":"QEDFeynmanDiagrams.make_up","text":"make_up(a::VirtualParticle, b::VirtualParticle, c::VirtualParticle)\n\nFor virtual particles a, b, and c, return true if a and b's joint momentum contributions add up to c's momentum contributions.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Public-Interface","page":"Public","title":"Public Interface","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]","category":"page"},{"location":"lib/public/#Types","page":"Public","title":"Types","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"FeynmanDiagram\nVirtualParticle","category":"page"},{"location":"lib/public/#QEDFeynmanDiagrams.FeynmanDiagram","page":"Public","title":"QEDFeynmanDiagrams.FeynmanDiagram","text":"FeynmanDiagram{N,E,U,T,M,FM} <: AbstractTreeLevelFeynmanDiagram\n\nAn implementation of AbstractTreeLevelFeynmanDiagram, representing Feynman diagrams of tree-level perturbative QED.\n\nThe type parameters are:\n\nN: The total number of fermion lines in the diagram, i.e., N := E + U + T\nE: The total number of external electrons/positron pairs in the scattering process.\nU: The total number of external muon/antimuon pairs in the scattering process.\nT: The total number of external tauon/antitauon pairs in the scattering process.\nM: The total number of external photons in the scattering process.\nFM: A FlatMatrix type to efficiently store the diagram layout in serial memory.\n\nnote: Note\nE, U, and T are numbers of Fermion lines while M is the number of individual external photons. This means the number of external legs is 2(E + U + T) + M.\n\nwarning: Warning\nWhile U and T can be non-zero in this type and the rest of the code in this package is ready to deal with muons and tauons, no types for them exist yet in the QEDjl-project. Therefore, some functions will throw unimplemented errors when used with non-zero values for U and T.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#QEDFeynmanDiagrams.VirtualParticle","page":"Public","title":"QEDFeynmanDiagrams.VirtualParticle","text":"VirtualParticle{\n    PROC<:AbstractProcessDefinition,\n    PT<:AbstractParticleType,\n    I,\n    O,\n}\n\nRepresentation of a virtual particle and the return type of the virtual_particles function. The type parameters are:\n\nPROC: The process this particle is a process of.\nPT: The particle type of this virtual particle, e.g. QEDcore.Photon or QEDcore.Electron.\nI: The number of incoming particles of the process, i.e. I := length(incoming_paritcles(PROC()))\nO: The number of outgoing particles of the process, i.e. O := length(outgoing_paritcles(PROC()))\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Functions","page":"Public","title":"Functions","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"external_particles\nfeynman_diagrams\ngenerate_DAG\nprocess\nvirtual_particles","category":"page"},{"location":"lib/public/#QEDFeynmanDiagrams.external_particles","page":"Public","title":"QEDFeynmanDiagrams.external_particles","text":"external_particles(diagram::AbstractTreeLevelFeynmanDiagram)\n\nReturn a tuple of the incoming and outgoing particles (QEDbase.AbstractParticleType) of the diagram.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#QEDFeynmanDiagrams.feynman_diagrams","page":"Public","title":"QEDFeynmanDiagrams.feynman_diagrams","text":"feynman_diagrams(proc::AbstractProcessDefinition)\n\nReturn all tree-level Feynman diagrams that contribute to the given process, in perturbative QED.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#QEDFeynmanDiagrams.generate_DAG","page":"Public","title":"QEDFeynmanDiagrams.generate_DAG","text":"generate_DAG(proc::AbstractProcessDefinition)\n\nGenerate and return a ComputableDAGs.DAG, representing the computation for the squared matrix element of this scattering process, summed over spin and polarization combinations allowed by the process.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#QEDbase.process","page":"Public","title":"QEDbase.process","text":"process(::AbstractTreeLevelFeynmanDiagram)::QEDbase.AbstractProcessDefinition\n\nInterface function that must be implemented for an instance of AbstractTreeLevelFeynmanDiagram.\n\nReturn the specific QEDbase.AbstractProcessDefinition which the given diagram is for.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#QEDFeynmanDiagrams.virtual_particles","page":"Public","title":"QEDFeynmanDiagrams.virtual_particles","text":"virtual_particles(::QEDbase.AbstractProcessDefinition, ::AbstractTreeLevelFeynmanDiagram)::Vector{VirtualParticle}\n\nInterface function that must be implemented for an instance of AbstractTreeLevelFeynmanDiagram.\n\nReturn an NTuple with N elements, where N is the number of virtual particles in this diagram. For tree-level Feynman diagrams, N = k - 3, where k is the number of external particles. The elements of the NTuple are themselves Tuples, containing for each virtual particle its QEDbase.AbstractParticleType and an NTuple{, Bool} indicating with a 1 that an incoming external particle's momentum contributes to the virtual particle's momentum, and a 0 otherwise. The second NTuple{, Bool} does the same for the outgoing external particles, which contribute their momentum negatively. From this definition follows that a particles' Boolean NTupless are equivalent to their inverse, i.e., BitArrays where every bit is negated.\n\nExample: Consider the Compton scattering process e^- + gamma to e^- + gamma with the diagram where the incoming electron interacts with the incoming photon first. For this diagram there is exactly one virtual particle, which is an electron. This electron's momentum can be represented as the sum of the two incoming particles' momenta, or  that of the two outgoing particles. In the second possible diagram, where the incoming electron interacts with the outgoing photon first, the virtual particle is still an electron but its momentum is the sum of the momenta of the incoming electron and the outgoing photon, or, equivalently, the outgoing electron and the incoming photon.\n\nvirtual_particles(::AbstractProcessDefinition)::Vector{VirtualParticle}\n\nFunction that returns all unique virtual particles of the given process.\n\nnote: Note\nThis function is usually costly to compute and used across multiple functions. Therefore, it caches its results using Memoization.jl.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"TBW","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"(Image: Virtual Particle Currents)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"For a usage example, please refer to the notebooks in the ./notebooks directory of the repository.","category":"page"},{"location":"contribution/#Contribution","page":"Contribution","title":"Contribution","text":"","category":"section"},{"location":"contribution/","page":"Contribution","title":"Contribution","text":"Feel free to open issues or pull requests to the official repository. Ideas, tips, bug reports, or contributions are all welcome.","category":"page"},{"location":"contribution/","page":"Contribution","title":"Contribution","text":"As part of the QEDjl-project, this repository uses gitflow. For details on the development and release process, see the Development Guide in the QuantumElectrodynamics.jl documentation.","category":"page"},{"location":"#QEDFeynmanDiagrams.jl","page":"QEDFeynmanDiagrams.jl","title":"QEDFeynmanDiagrams.jl","text":"","category":"section"},{"location":"","page":"QEDFeynmanDiagrams.jl","title":"QEDFeynmanDiagrams.jl","text":"This project is dedicated to generating Feynman diagrams for scattering processes in perturbative QED. It is part of the QEDjl-project and relies on QEDcore.jl. Furthermore, it can generate code to compute the matrix element for scattering processes, using ComputableDAGs.jl and RuntimeGeneratedFunctions.jl.","category":"page"},{"location":"","page":"QEDFeynmanDiagrams.jl","title":"QEDFeynmanDiagrams.jl","text":"For example usage, see the n-photon Compton or trident pages.","category":"page"},{"location":"","page":"QEDFeynmanDiagrams.jl","title":"QEDFeynmanDiagrams.jl","text":"The inner workings of the project are explained in the manual.","category":"page"},{"location":"examples/compton/","page":"Compton","title":"Compton","text":"EditURL = \"compton.jl\"","category":"page"},{"location":"examples/compton/#n-Photon-Compton-Scattering-Process","page":"Compton","title":"n-Photon Compton Scattering Process","text":"","category":"section"},{"location":"examples/compton/","page":"Compton","title":"Compton","text":"In this file, we set up an n-photon Compton scattering process. A Compton scattering process looks like k^n e^- to k e^-.","category":"page"},{"location":"examples/compton/","page":"Compton","title":"Compton","text":"You can download this file as a jupyter notebook.","category":"page"},{"location":"examples/compton/","page":"Compton","title":"Compton","text":"using QEDFeynmanDiagrams","category":"page"},{"location":"examples/compton/","page":"Compton","title":"Compton","text":"We need some of the packages of the QEDjl-project for base functionality and the ScatteringProcess type.","category":"page"},{"location":"examples/compton/","page":"Compton","title":"Compton","text":"using QEDcore\nusing QEDprocesses","category":"page"},{"location":"examples/compton/","page":"Compton","title":"Compton","text":"Let's decide how many photons our electron interacts with:","category":"page"},{"location":"examples/compton/","page":"Compton","title":"Compton","text":"n = 4;\nnothing #hide","category":"page"},{"location":"examples/compton/","page":"Compton","title":"Compton","text":"Now we setup the scattering process accordingly. We consider all spin/polarization combinations of the particles except for the incoming photons, where the polarizations are synced using QEDbase.SyncedPolarization. This emulates all synced photons having the same, but still indefinite, polarization, for example from a laser.","category":"page"},{"location":"examples/compton/","page":"Compton","title":"Compton","text":"proc = ScatteringProcess(\n    (Electron(), ntuple(_ -> Photon(), n)...),     # incoming particles\n    (Electron(), Photon()),                        # outgoing particles\n    (AllSpin(), ntuple(_ -> SyncedPol(1), n)...),  # incoming particle spin/pols\n    (AllSpin(), AllPol()),                         # outgoing particle spin/pols\n)","category":"page"},{"location":"examples/compton/","page":"Compton","title":"Compton","text":"The feynman_diagrams function returns an iterator for all possible Feynman diagrams for this scattering process. With its length overload, we can check how many diagrams there are. For an n-photon Compton process with n incoming photons, this should be (n+1).","category":"page"},{"location":"examples/compton/","page":"Compton","title":"Compton","text":"length(feynman_diagrams(proc))","category":"page"},{"location":"examples/compton/","page":"Compton","title":"Compton","text":"Next, we can generate the DAG representing the computation for our scattering process' squared matrix element. This uses ComputableDAGs.jl.","category":"page"},{"location":"examples/compton/","page":"Compton","title":"Compton","text":"dag = generate_DAG(proc)","category":"page"},{"location":"examples/compton/","page":"Compton","title":"Compton","text":"In this graph output you can see the number of nodes necessary to compute. Note that for larger processes, the number of total nodes can be lower than the number of Feynman diagrams, even with the added complexity of considering multiple spin and polarization combinations. This is the result of efficient reuse of reappearing parts of Feynman diagrams.","category":"page"},{"location":"examples/compton/","page":"Compton","title":"Compton","text":"To continue, we will need ComputableDAGs.jl. Since ComputableDAGs.jl uses RuntimeGeneratedFunctions as the return type of ComputableDAGs.get_compute_function, we need to initialize it in our current module.","category":"page"},{"location":"examples/compton/","page":"Compton","title":"Compton","text":"using ComputableDAGs\nusing RuntimeGeneratedFunctions\nRuntimeGeneratedFunctions.init(@__MODULE__)","category":"page"},{"location":"examples/compton/","page":"Compton","title":"Compton","text":"With the DAG, the process, and RuntimeGeneratedFunctions initalized, we can now generate the actual computable function:","category":"page"},{"location":"examples/compton/","page":"Compton","title":"Compton","text":"func = get_compute_function(dag, proc, cpu_st(), @__MODULE__);\nnothing #hide","category":"page"},{"location":"examples/compton/","page":"Compton","title":"Compton","text":"Now we need an input for the function, which is a QEDcore.PhaseSpacePoint. For now, we generate random momenta for every particle. In the future, QEDevents will be able to generate physical PhaseSpacePoints.","category":"page"},{"location":"examples/compton/","page":"Compton","title":"Compton","text":"psp = PhaseSpacePoint(\n    proc,\n    PerturbativeQED(),\n    PhasespaceDefinition(SphericalCoordinateSystem(), ElectronRestFrame()),\n    tuple((rand(SFourMomentum) for _ in 1:number_incoming_particles(proc))...),\n    tuple((rand(SFourMomentum) for _ in 1:number_outgoing_particles(proc))...),\n)","category":"page"},{"location":"examples/compton/","page":"Compton","title":"Compton","text":"Finally, we can test that the function actually runs and computes something by simply calling it on the PhaseSpacePoint:","category":"page"},{"location":"examples/compton/","page":"Compton","title":"Compton","text":"func(psp)","category":"page"},{"location":"examples/compton/","page":"Compton","title":"Compton","text":"If we want, we can benchmark the execution speed too:","category":"page"},{"location":"examples/compton/","page":"Compton","title":"Compton","text":"using BenchmarkTools\n@benchmark func($psp)","category":"page"},{"location":"examples/compton/","page":"Compton","title":"Compton","text":"","category":"page"},{"location":"examples/compton/","page":"Compton","title":"Compton","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/trident/","page":"Trident","title":"Trident","text":"EditURL = \"trident.jl\"","category":"page"},{"location":"examples/trident/#n-Pair-Trident-Scattering-Process","page":"Trident","title":"n-Pair Trident Scattering Process","text":"","category":"section"},{"location":"examples/trident/","page":"Trident","title":"Trident","text":"In this file, we set up an n-pair trident scattering process. A trident process looks like k e^- to e^- (e^- e^+)^n.","category":"page"},{"location":"examples/trident/","page":"Trident","title":"Trident","text":"You can download this file as a jupyter notebook.","category":"page"},{"location":"examples/trident/","page":"Trident","title":"Trident","text":"using QEDFeynmanDiagrams","category":"page"},{"location":"examples/trident/","page":"Trident","title":"Trident","text":"We need some of the packages of the QEDjl-project for base functionality and the ScatteringProcess type.","category":"page"},{"location":"examples/trident/","page":"Trident","title":"Trident","text":"using QEDcore\nusing QEDprocesses","category":"page"},{"location":"examples/trident/","page":"Trident","title":"Trident","text":"Let's decide how many pairs our trident should produce:","category":"page"},{"location":"examples/trident/","page":"Trident","title":"Trident","text":"n = 2;\nnothing #hide","category":"page"},{"location":"examples/trident/","page":"Trident","title":"Trident","text":"Now we setup the scattering process accordingly. We only consider a single spin/polarization combination here. For an example with many spin and polarization combinations, refer to the n-photon Compton example","category":"page"},{"location":"examples/trident/","page":"Trident","title":"Trident","text":"proc = ScatteringProcess(\n    (Electron(), Photon()),                                                         # incoming particles\n    (Electron(), ntuple(_ -> Electron(), n)..., ntuple(_ -> Positron(), n)...),     # outgoing particles\n    (SpinUp(), PolX()),                                                             # incoming particle spin/pols\n    (SpinUp(), ntuple(_ -> SpinUp(), 2 * n)...),                                    # outgoing particle spin/pols\n)","category":"page"},{"location":"examples/trident/","page":"Trident","title":"Trident","text":"The feynman_diagrams function returns an iterator for all possible Feynman diagrams for this scattering process. With its length overload, we can check how many diagrams there are.","category":"page"},{"location":"examples/trident/","page":"Trident","title":"Trident","text":"length(feynman_diagrams(proc))","category":"page"},{"location":"examples/trident/","page":"Trident","title":"Trident","text":"Next, we can generate the DAG representing the computation for our scattering process' squared matrix element. This uses ComputableDAGs.jl.","category":"page"},{"location":"examples/trident/","page":"Trident","title":"Trident","text":"dag = generate_DAG(proc)","category":"page"},{"location":"examples/trident/","page":"Trident","title":"Trident","text":"To continue, we will need ComputableDAGs.jl. Since ComputableDAGs.jl uses RuntimeGeneratedFunctions as the return type of ComputableDAGs.get_compute_function, we need to initialize it in our current module.","category":"page"},{"location":"examples/trident/","page":"Trident","title":"Trident","text":"using ComputableDAGs\nusing RuntimeGeneratedFunctions\nRuntimeGeneratedFunctions.init(@__MODULE__)","category":"page"},{"location":"examples/trident/","page":"Trident","title":"Trident","text":"With the DAG, the process, and RuntimeGeneratedFunctions initalized, we can now generate the actual computable function:","category":"page"},{"location":"examples/trident/","page":"Trident","title":"Trident","text":"func = get_compute_function(dag, proc, cpu_st(), @__MODULE__);\nnothing #hide","category":"page"},{"location":"examples/trident/","page":"Trident","title":"Trident","text":"Now we need an input for the function, which is a QEDcore.PhaseSpacePoint. For now, we generate random momenta for every particle. In the future, QEDevents will be able to generate physical PhaseSpacePoints.","category":"page"},{"location":"examples/trident/","page":"Trident","title":"Trident","text":"psp = PhaseSpacePoint(\n    proc,\n    PerturbativeQED(),\n    PhasespaceDefinition(SphericalCoordinateSystem(), ElectronRestFrame()),\n    tuple((rand(SFourMomentum) for _ in 1:number_incoming_particles(proc))...),\n    tuple((rand(SFourMomentum) for _ in 1:number_outgoing_particles(proc))...),\n)","category":"page"},{"location":"examples/trident/","page":"Trident","title":"Trident","text":"Finally, we can test that the function actually runs and computes something by simply calling it on the PhaseSpacePoint:","category":"page"},{"location":"examples/trident/","page":"Trident","title":"Trident","text":"func(psp)","category":"page"},{"location":"examples/trident/","page":"Trident","title":"Trident","text":"If we want, we can benchmark the execution speed too:","category":"page"},{"location":"examples/trident/","page":"Trident","title":"Trident","text":"using BenchmarkTools\n@benchmark func($psp)","category":"page"},{"location":"examples/trident/","page":"Trident","title":"Trident","text":"","category":"page"},{"location":"examples/trident/","page":"Trident","title":"Trident","text":"This page was generated using Literate.jl.","category":"page"}]
}
